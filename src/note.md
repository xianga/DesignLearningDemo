#### 什么是队列、栈、链表
- 队列:一种先进先出的数据结构；
- 栈：一种先进后出的数据结构；
- 链表：一种不连续的存储结构，由许多节点组成；每个节点由数据和指向下一个节点的指针组成；
#### 队列、栈的两种实现方式
- 都可以通过数组、链表两种方式实现
- 数组实现方法：MyArrayStack,MyArrayQueue
#### 什么是树
- 树是一种数据结构；它是有多个节点组成的有层次关系的集合；分为有序树、无序树；
#### 树的遍历方法
- 前中后序遍历；前中后指的是根节点相对于左右节点的位置；
#### 什么是堆
- 堆是种特殊的树结构，其根节点最小时称为最小堆，最大时称为最大堆；
#### 什么是图

#### 栈和队列的相同和不同之处
- 相同：都是只允许在端点处对数据进行操作
- 不同：栈先进后出、队列先进先出
#### 两个栈实现队列，和两个队列实现栈（了解）
- 两个栈实现队列：
    - 存： 往A栈里面存；
    - 取：判断B栈里是否有数据，有则取，没有则把A栈中的数据先存入B栈再取
- 两个队列实现栈：
    - 存：往A存 先存入数据，再判断B是否有数据 有则把B队里的数据往A存；
    - 取：判断哪个队列有数据 ，从中拿数据
#### 排序都有哪几种方法？
- 快速排序：选择第一个数作为基准，比他小的往左移，大的往右移，递归处理左边部分和右边部分
- 归并排序：先拆分为小数组，排序后在回溯归并
- 冒泡排序
- 选择排序：扑克牌选择从大到小排
- 插入排序：往已排好的扑克牌插入新牌
- 实现见SortUtil
#### 单链表的遍历和逆序
- 见LinkedList;
#### tcp,udp区别
- tcp面向连接，通信前需要建立连接，udp面向无连接，不需要建立连接；
- tcp提供可靠的通信服务、udp不保证可靠交付
- tcp是点对点的连接、udp可以一对多、多对多
- tcp系统资源要求高
#### HTTP请求和响应的全过程
- 域名解析
- 浏览器缓存->系统缓存->hosts文件->DNS服务器->拿到域名对应IP地址
- 建立tcp连接
    - 3次握手
- 发起HTTP请求、GET/POST请求
- 服务器响应HTTP请求，返回HTML
- 浏览器解析HTML，并请求资源，渲染展示
- TCP连接结束断开
  -   四次挥手
#### get和post的区别
- get参数是带在url上，有长度限制，这个限制是由于浏览器url长度的限制，和协议无关
- post请求参数带在方法体中，没有限制
#### forward和redirect的区别
- redirect：重定向，url会展示在浏览器上，相当于重新发送了一次请求，效率较低
- forward：转发，服务器将请求使用另一个url来作为响应，不会表现在浏览器上
#### osi七层模型
- 应用层
- 表示层
- 会话层
- 传输层
- 网络层
- 数据链路层
- 物理层
#### tcp/ip四层模型及原理
- 应用层
- 传输层
- 网络层
- 物理层
#### 三次握手、四次挥手
- 三次握手：
- 发送SYN
- 服务器返回SYN+ACK
- 发送ACK
- 四次挥手：
- 发送FIN
- 服务器返回ACK
- 服务器发送FIN
- 返回ACK
#### 数据库范式
- 第一范式：所有属性不可再分
- 第二范式：非主属性和码要有完全依赖关系
- 第三范式：消除非主属性对码的传递依赖
#### 数据库事务四大特性
- 原子性
- 一致性
- 隔离性
- 持久性

### JVM
#### JVM是什么
- JAVA虚拟机
#### JVM运行时数据区(内存)由什么组成
- 线程隔离
    - 程序计数器
    - 虚拟机栈
    - 本地方法栈
- 线程共享
    - 堆
    - 方法区
#### 程序计数器
- 用于记录每个线程当前执行到第几行，方便线程切换时恢复执行；
- 如果当前正在执行native方法，则为空(undefined)
#### 虚拟机栈
- 由栈帧组成
    - 栈帧
    - 定义：每个方法被调用到执行完成的过程，对应着一个栈帧入栈和出栈的过程；
        - 局部变量表(栈内存)：存储基本数据类型、对象引用
        - 操作数栈
        - 动态链接
        - 方法出口
        - 附加信息
#### 本地方法栈
- 与虚拟机栈功能类似，提供与本地方法使用
#### 堆
- 几乎所有的对象都在堆分配内存
- 垃圾回收器主要收集的地方
#### 方法区
- 类似永久代
- 保存类信息，常量，静态变量等
- 运行时常量池
    - class文件中的常量池会在类加载后进入运行时常量池
    - String类的intern方法可以将字符串加入运行时常量池
    

### 垃圾收集器(GC)
#### 如何判断对象是否存活
- 引用计数法
    - 定义：通过给对象增加一个引用计数器，一个引用加1，一个引用失效则减1，为0时则代表对象失效
    - 缺陷：无法解决循环引用的问题，A引用B,B引用A，但是都是无效的对象；发生内存泄露；
- 对象可达法(解决引用计数法的缺陷)
    - 定义：通过一系列GC Roots为起点，向下搜索无法到达的对象，判定为无效的对象；
    - GC Roots
        - 虚拟机栈中引用的对象
        - 方法区中类静态属性引用的对象
        - 方法区中常量引用的对象
        - 本地方法栈中JNI引用的对象
- 对象被判定为死亡时，可以通过实现finalize函数来拯救一次自己，第二次则无效，因为系统只会自动调用一次finalize方法；
#### 引用类型
- 强引用：new 出来的对象都是强引用；不会被回收
- 软引用：内存充足时不会被回收；使用SoftReference实现
- 弱引用：下次GC会被回收；使用WeakReference实现
- 虚引用：使用PhantomReference实现；目的是在对象被回收时受到一个系统通知；
#### 垃圾收集算法
- 标记-清除算法
    - 定义：分为标记、清除两个过程
    - 缺点：
        - 效率低
        - 清除后空间分散
    - 适用老年代使用
- 标记-压缩算法
    - 定义：标记后不是直接清除，而是先将存活的对象移到一端，然后直接清理掉另一端
    - 解决了标记-清除算法空间分散的问题
- 复制算法
    - 定义：将内存分为两份，每次只使用一份，清除时将还存活的对象移到另一半，然后将正在使用的一半内存全部清除
    - 优点：高效
    - 缺点
        - 内存只使用了一半
        - 对象存活率高时不适用，因为复制耗费时间过多，不适用于老年代；
    - 改进：将内存分为一块大的新生区和两块小的幸存区；每次将存活的对象存入未使用的幸存区；将新生区和使用的幸存区清空；
    幸存区不够时，将会使用老年代来保证有空间可以分配
    
    
    
#### 为什么使用redis
- redis作为缓存提高效率
- 支持多个数据类型：String、List、Map、Set
- 提供持久化操作
#### 为什么使用redis不直接使用map
- redis可以提供持久化数据，即使服务器重启也不会丢失缓存
- redis支持集群共享
