--- 
    参考:http://yitaicloud.com
--- 
#### 开发中java用的比较多的数据结构有哪些
     List、Map、Set
#### HashMap底层的基本实现
    HashMap底层使用数据+链表的形式实现；
    主要是通过key的hash将数据以key-value的形式存入数组；
    当发生hash冲突时，通过链表法解决冲突；   
    当链表长度超过8时，会将链表转化为树；
    第一次put操作时，才初始化数组，初始大小为16，设置大小自动补充至2的指数，用于使用位运算代替取余操作；
    扩容为2倍；
    通过重写hashCode方法和equals方法来确定key是否相等；
    加载因子为0.75，当size大于最大容量*加载因子则会触发扩容；
#### 操作系统中 heap 和 stack 的区别
    堆：一般由程序员分配和释放
    栈：由编译器自动分配释放，存储函数的参数、局部变量等；
#### 什么是AOP
    Aspect Oriented Program的首字母缩写，面向切面编程；
    经典应用为：日志记录、权限判断、事务控制；
#### 什么是基于注解的切面实现
    通过@Aspect、@PointCut注解将一个类定义为切面，通过切入点定义切入哪个类的哪个方法；
#### 什么是 对象/关系 映射集成模块
    Object Relational Mapping 简称ORM，是通过使用描述对象和数据库之间映射的元数据，
    将面向对象编程的对象持久化到数据库中；本质是将数据从一种形式转化为另一种形式；
#### 什么是 Java 的反射机制
    反射机制是指在运行时，对于任意一个类，都能够知道并调用这个类的所有属性和方法；
    这种动态获取信息和动态调用对象方法的功能称为java的反射机制；
#### 什么是 ACID
    A:Atomic原子性
    C:Consistency一致性
    I:Isolation独立性
    D:Durability持久性
#### Cookie 和 Session的区别
- 存取数据类型：cookie只能存储ASCII字符串，其他编码或者二进制数据需要进行编码转换；Session对类型不做限制；
- 安全问题：Cookie存储在客户端中，对用户可见；Session存在服务器中；
#### fail-fast 与 fail-safe 机制有什么区别
- fail-fast机制：当在遍历一个集合时，当集合结构被修改，会抛出ConcurrentModificationException
- fail-safe机制：每次遍历一个集合，都会复制一份集合出来；可能导致读到的数据不是最新的数据；
#### get 和 post请求的区别
    get:参数是带在url后面的，有长度限制，这个长度限制是由浏览器限制的url长度；
    post:参数是带在请求体中，没有长度限制
#### Interface 与 abstract 类的区别
    接口：
        不能实例化；
        不能包含任何非常量成员，任何属性都是隐含public staic final
        方法要么是抽象方法，要么是静态方法；静态方法需要写方法体；
        可以多实现；
        jdk1.8提供了接口默认方法，可以带有方法体；使用defau修饰；
    abstract类：
        不能实例化；
        只能但继承；
        可以有0到多个抽象方法；
        主要是通过继承达到代码复用的目的；
#### IOC是什么
    IOC(Inversion of Control)：控制反转又叫依赖注入DI(Dependency Injection)，
    将控制权(创建对象和对象之间的依赖关系的权利)交给spring容器；
    优点：资源集中管理，实现资源的可配置和易管理；降低了使用资源双方的依赖程度，也就是我们说的耦合度；
#### IO 和 NIO，NIO优点
    IO:阻塞；面向流；每个IO都对应一个处理线程；当线程多的时候，线程上下文切换会很浪费时间；
    NIO:非阻塞；面向缓冲；通过一个selector选择器来监视多个通道，当有线程就绪时，进行处理；
#### JRE、JDK、JVM 及 JIT 之间有什么不同
        JRE:Java运行环境
        JDK:Java开发工具，包含JRE
        JVM:Java虚拟机
        JIT:即时编译；当代码执行的次数超过一定的阈值时，会将 Java 字节码转换为本地代码，这样有利大幅度提高 Java 应用的性能
#### MVC的各个部分都有那些技术来实现?如何实现?
    M：Model,通常用JavaBean实现
    V：View，通常用Jsp实现
    C：Controller，通常是一个Servlet
#### 一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制
    可以，只能有一个public类
#### 简单说说你了解的类加载器。是否实现过类加载器
- 类加载过程：
    - 加载类文件：通过类的字节码文件创建一个Class对象
    - 链接
        - 验证：验证Class文件是否符合虚拟机要求；
        - 准备：为类变量(Static修饰的变量分配内存并设置初始值)，不包含final修饰的static变量
        - 解析：主要是讲符号引用替换成直接引用；
    - 初始化：初始化类，如果有父类，则对其进行初始化；同时对变量赋值；
- 虚拟机类加载器
    - 启动类加载器(BootstraClassLoader)：负责加载/JAVAHOME/lib下的类
    - 拓展加载器(ExtensionClassLoader)：负责加载/JAVA/lib/ext下的类
    - 系统加载器(SystemClassLoader)：负责加载Classpath下的类；
- 双亲委派模型：
    当一个类加载器准备加载类时，会把这个操作委托给父加载器去操作，递归向上委托；
    如果父类无法完成加载，则子类才尝试自己去加载；
- 自定义类加载器：继承ClassLoader,重写FindClass方法
#### 请简述 Servlet 的生命周期及其相关的方法
- 初始化：通过调用Servlet的init方法来初始化；在第一次创建时调用一次；
- 服务：Web服务器调用Service来处理请求，每一个请求产生一个线程；
- 销毁：destroy方法，只会调用一次；调用后，servlet对象被标记为垃圾回收；
#### 请简述一下 Ajax 的原理及实现步骤
#### 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”
    Java虚拟机是一个虚构出来的计算机，Java通过生成字节码运行在Java虚拟机上，
    虚拟机再将字节码转化为对应平台上的机器码，以此实现跨平台运行；
#### 什么是懒加载（Lazy Loading）
    懒加载：即等到需要使用的再加载初始化；
    
#### 什么是尾递归，为什么需要尾递归
    定义：函数返回之前的最后一个操作若是递归调用，则该函数进行了尾递归；
    尾递归的好处：函数每一次调用都会压入一个栈帧，当函数调用过多时，就有可能发生栈溢出；
    尾递归的时候，由于已经知道f(n-1)的结果，计算f(n)就不需要重新压入栈帧，直接覆盖就好，编译器会优化；

#### 什么是finalize()方法
    finalize方法是Object的方法
- 什么时候调用<br>
如果实现了该方法，则GC在准备回收该对象时执行一次该方法，并在下一次垃圾回收时，才真正回收对象内存；只会调用一次；
- 析构函数(finalization)的目的是什么<br>
    析构函数目的是撤销对象前、完成一些清理工作，比如释放资源。释放了之后这些资源可以被回收，重新利用。
- final 和 finalize 的区别
    - final是关键字，用于定义一个类不可继承，一个方法不可重写、重载，一个变量不可重新赋值；
    - finalize是Object的一个方法
#### final的用法，作用
    - 用来修饰变量，需要在声明时初始化或者在构造函数中初始化；
    - 用来修饰方法，修饰方法时，方法不可重写；
    - 用来修饰类，类不可被继承，不能和abstract同时使用；
    - 用来修饰方法的形参，当形参被修饰为final时，在方法中不能对形参进行修改；
#### final 与 static 关键字可以用于哪里？它们的作用是什么？
    用于修饰成员变量和成员方法，可以理解为“全局常量”，
    对于变量表示一旦给定值就不可以修改，并且通过类名可以访问；
    对于方法表示不可覆盖，并且可以通过类名直接访问

#### finally的作用
- 用法：try-catch-finally，用来确保finally中的代码会执行，
- 例外：Try中执行System.exit(1);
- finally中return的结果
    - 情况一：如果finally中有return语句，则会将try中的return语句“覆盖”掉，直接执行finally中的return语句，得到返回值，这样便无法得到try之前保留好的返回值。
    - 情况二：如果finally中没有return语句，也没有改变要返回值，则执行完finally中的语句后，会接着执行try中的return语句，返回之前保留的值。
    - 情况三：如果finally中没有return语句，但是改变了要返回的值，这里有点类似与引用传递和值传递的区别，分以下两种情况：
        - 1）如果return的数据是基本数据类型或文本字符串，则在finally中对该基本数据的改变不起作用，try中的return语句依然会返回进入finally块之前保留的值。
        - 2）如果return的数据是引用数据类型，而在finally中对该引用数据类型的属性值的改变起作用，try中的return语句返回的就是在finally中改变后的该属性的值。

#### 能否在运行时向 static final 类型的赋值
    不可以，被static final修饰的变量只能在被定义的时候或者类的静态代码块中初始化，一旦赋值后就不能在改变了。
    static final相当于类常量，就是在类被加载进内存的时候就要为属性分配内存，static块就是类被加载的时候执行且被执行一次，所以可以在其中进行初始化。
    如果不是静态变量，则可以使用反射进行修改；
#### 使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变
    引用不能变
#### 一个类被声明为final类型，表示了什么意思
    该类比较完善，不能被继承
#### throws, throw, try, catch, finally分别代表什么意义
    throw是指的语句抛出一个异常
    throws指的是声明方法可能抛出的异常类型
    try表示一个代码块，可能抛出异常
    catch用来捕捉异常
    finally用来保证try代码块无论是否正常运行，都会执行的一个代码块
#### Java 有几种修饰符？分别用来修饰什么
    public、private、protected可以用来修饰类、方法、成员变量
    abstract 修饰类、方法，代表抽象类，抽象方法
#### volatile 修饰符的有过什么实践
#### volatile 变量是什么？
    用来确保将变量的更新操作通知到其他线程；可以保证下一个读取操作会在前一个写操作之后发生，即可见性
#### volatile 变量和 atomic 变量有什么不同
    volatile无法保证原子性
#### volatile 类型变量提供什么保证？能使得一个非原子操作变成原子操作吗
    提供可见性保证，不能保证原子性
#### 能创建 volatile 数组吗？
    可以，volatile修饰的变量如果是对象或数组之类的，其含义是对象获数组的地址具有可见性，
    但是数组或对象内部的成员改变不具备可见性
#### transient变量有什么特点
    不参与序列化
#### super什么时候使用
    访问父类的属性、方法、构造函数时使用
#### public static void 写成 static public void会怎样
    一样
#### 说明一下public static void main(String args[])这段声明里每个关键字的作用
    public ：代表该函数的访问权限是最大的。
    static ：代表主函数随着类的加载，就已经存在了。
    void： 主函数没有具体的返回值
    main ： 不是关键字，是一个特殊的单词可以被jvm识别。
    (String[] args) 函数的参数，参数类型是一个数组，该数组中的元素是字符串。字符串类型的数组。
    主函数的格式是固定的：jvm能够识别
#### 请说出作用域public, private, protected, 以及不写时的区别
    public：所有类都可以访问
    private：只有类本身可以访问
    protected：类、同包及子类可以访问，
    不写：类及同包下的类可以访问
#### sizeof 是Java 的关键字吗
    不是
#### static的用法，作用
 - 可以用来修饰变量，静态代码块，静态方法，内部类，内部接口
 - 表示全局，被修饰的方法独立于类的所有变量
 - 被修饰的代码块会在虚拟机加载该类的的时候执行一次；
#### static class 与 non static class的区别
    静态内部类不需要外部类的实例，非静态内部类需要
    静态类不能访问外部类的非静态成员
#### static 关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法，静态类型有什么特点？
    表示静态，静态成员函数只能访问静态变量
    不可以重写；private不支持继承，所以无法重写；
    可以定义一个相同的static方法，但不是重写，只是隐藏了父类的方法；
#### main() 方法为什么必须是静态的？能不能声明 main() 方法为非静态？
    静态方法不需要依赖于对象来运行，只要有类就行；main作为程序的入口，这之前不可能有对象；
    所有main方法必须是静态的方法
#### 是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用
    不可以，因为非静态方法依赖于对象存在，静态方法优先与对象存在
#### 静态变量在什么时候加载？编译期还是运行期？静态代码块加载的时机呢？
    随着类的加载而加载；运行期；
#### 成员方法是否可以访问静态变量？为什么静态方法不能访问成员变量？
    可以
#### switch 语句中的表达式可以是什么类型数据
    byte、short、int、char、String，还有枚举类型
    String使用hashcode和equals支持
#### while 循环和 do 循环有什么不同
    while是先判断在执行如果判断不成立，就不会执行；do/while是先执行在判断，不管判断是否成立都会执行一次
#### &操作符和&&操作符有什么区别?
    &：位运算
    &&：布尔运算、短路与运算
#### a = a + b 与 a += b 的区别？
    =:赋值运算符，在编译器将右边的表达式结果计算出来后，和左边的变量类型比较精度，
      如果左边的变量精度低于右边的结果的精度，编译器会显式的报错，告诉程序员去强制转型。
      （若a精度类型弱于b，a = a + b出错，编译检查报错）最后将表达式的结果复制到变量所在的内存区。
    +=:编译器自动隐式直接将+=运算符后面的操作数强制装换为前面变量的类型，
       然后在变量所在的内存区上直接根据右边的操作数修改左边变量内存存储的二进制数值最后达到和赋值运算符相同的目的。
       与前者相比，由于后者是位操作，效率也较前者高
#### 3*0.1 == 0.3 将会返回什么？true 还是 false？
    false,小数点后不精确
#### float f=3.4; 是否正确？
    不正确，需要加上f
#### short s1 = 1; s1 = s1 + 1;有什么错?
    1和s1类型不匹配，无法向下转型
## 数据结构
### HashMap
#### HashMap的工作原理是什么
    基于hash
#### 内部的数据结构是什么
    存key和value的Node 数组加链表
#### HashMap 的 table的容量如何确定？loadFactor 是什么？ 该容量如何变化？这种变化会带来什么问题？
    容量默认值为16
    loadFactor为负载因子，当大小超过容量*负载因子时，会引发扩容；
    该容量和table容量都成倍拓展
    当重新调整hash的时候存在条件竞争，如果两个线程都发现hashMap需要调整大小，他们会同时试着调整大小，就会发生冲突
#### HashMap 实现的数据结构是什么？如何实现
    通过hash对map大小求余确定下标，hash冲突时通过拉链法解决冲突；
    通过equals函数确定两个key是否完全相同
#### HashMap 和 HashTable、ConcurrentHashMap 的区别
    HashMap不是线程安全的，可以存入null
    HashTable通过对方法加synchronized关键字实现线程安全,不可以存入null
    ConcurrentHashmap通过对桶加锁实现同步
#### HashMap的遍历方式及效率
- 通过Map.keySet遍历key和value
- 通过Map.entrySet使用iterator遍历key和value
- 通过Map.entrySet遍历key和value；最快
- 通过Map.values()遍历所有的value，但不能遍历key
#### HashMap、LinkedMap、TreeMap的区别
#### 如何决定选用HashMap还是TreeMap
#### ConcurrentHashMap原理、内部实现


